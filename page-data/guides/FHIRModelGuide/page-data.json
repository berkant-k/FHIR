{"componentChunkName":"component---src-pages-guides-fhir-model-guide-md","path":"/guides/FHIRModelGuide/","result":{"pageContext":{"frontmatter":{"slug":"/FHIR/guides/FHIRModelGuide","title":"FHIR Model Guide","date":"2019-10-25 12:00:00 -0400"},"relativePagePath":"/guides/FHIRModelGuide.md","titleType":"append","MdxNode":{"id":"3bda34b3-8618-5e29-ad69-e2552cabc065","children":[],"parent":"1fe22d6b-80b7-5af6-8d05-6433dd8b231e","internal":{"content":"---\nslug:  \"/FHIR/guides/FHIRModelGuide\"\ntitle: \"FHIR Model Guide\"\ndate:  \"2019-10-25 12:00:00 -0400\"\n---\n\n## Overview\n\nThe FHIR model component provides Java APIs for parsing, building, generating and validating FHIR resources. Java model classes that represent FHIR resources and data types are generated directly from the structure definitions distributed with the spec. All model objects are thread-safe and immutable. Each model class implements the Java builder pattern (Effective Java, Joshua Bloch) and the visitor pattern (GoF). The classes also implement Java equals, hashCode and toString methods. All date/time processing is done using the Java time library.\n\nMany of the data type classes include additional factory methods to facilitate object construction for common use cases. The model includes generated Javadoc comments complete with excerpts taken directly from the specification. Model classes also include Java annotations for constraints (`@Constraint`), required elements (`@Required`), choice element types (`@Choice`) and value set bindings (`@Binding`). Value set bindings are implemented using Code subclasses with constant fields and nested enumerations. Backbone elements are implemented as Java nested classes to keep them organized.\n\nAll schema-level (structure, cardinality, value domain) and global (empty resource, empty element) constraint validation is happens during object construction. This means that it is virtually impossible to build a schema invalid FHIR resource using the APIs. Additional constraint validation (invariants, profile, terminology) is performed using the FHIRValidator class. FHIRParser and FHIRGenerator classes are used to parse and generate both JSON and XML formats. FHIRPathEvaluator is a FHIRPath evaluation engine built on an ANTLR4 generated parser. It implements are large portion of the FHIRPath specification and is used for validation and search parameter value extraction.\n\n## Building a Resource using the FHIR Model API\n\nThe FHIR model API implements the Builder pattern for constructing Resource instances.\n\n```\nObservation bodyWeight = Observation.builder()\n    .meta(Meta.builder()\n        .profile(Canonical.of(\"http://hl7.org/fhir/StructureDefinition/bodyweight\"))\n        .build())\n    .status(ObservationStatus.FINAL)\n    .effective(DateTime.builder()\n        .value(\"2019-01-01\")\n        .build())\n    .category(CodeableConcept.builder()\n        .coding(Coding.builder()\n            .system(Uri.of(\"http://terminology.hl7.org/CodeSystem/observation-category\"))\n            .code(Code.of(\"vital-signs\"))\n            .build())\n        .build())\n    .code(CodeableConcept.builder()\n        .coding(Coding.builder()\n            .system(Uri.of(\"http://loinc.org\"))\n            .code(Code.of(\"29463-7\"))\n            .build())\n        .build())\n    .value(Quantity.builder()\n        .value(Decimal.of(200))\n        .system(Uri.of(\"http://unitsofmeasure.org\"))\n        .code(Code.of(\"[lb_av]\"))\n        .unit(\"lbs\")\n        .build())\n    .build();\n```\n\nIn the example above, a number of different builder classes are used:\n\n- `Observation.Builder`\n- `DateTime.Builder`\n- `CodeableConcept.Builder`\n- `Quantity.Builder`\n\nEvery type in the model that represents a FHIR resource or element has a corresponding nested, static Builder class used for constructing thread-safe, immutable instances.\n\nSeveral static factory / utility methods are also used:\n\n- `Canonical.of(...)`\n- `Uri.of(...)`\n- `Code.of(...)`\n\nMany of the primitive data types contain this type of \"helper\" method.\n\n## Modifying a model object\n\nAlthough model objects are immutable, the `toBuilder()` method can be used to construct a builder with the same values.\nThis builder can then be modified and built into a new model object.\n```\nObservation modifiedBodyWeight = bodyWeight.toBuilder()\n    .value(bodyWeight.getValue().as(Quantity.class).toBuilder()\n        .value(Decimal.of(210))\n        .build())\n    .build();\n```\n\nAlternatively, if the fhir-path module is included, objects can be modified via FHIRPathUtil or FHIRPathPatch.\n```\n// Using FHIRPathUtil\nObservation patchedBodyWeight1 = FHIRPathUtil.replace(bodyWeight, \"Observation.value.value\", Decimal.of(210));\n\n// Using FHIRPathPatch (useful if applying a series of patches to many resource instances)\nFHIRPathPatch patch = FHIRPathPatch.builder()\n    .replace(\"Observation.value.value\", Decimal.of(210))\n    .build();\nObservation patchedBodyWeight2 = patch.apply(bodyWeight);\n```\n\n## Parsing a Resource from an InputStream or Reader\n\n```\n// Parse JSON from InputStream\nInputStream in = getInputStream(\"JSON/bodyweight.json\");\nObservation observation = FHIRParser.parser(Format.JSON).parse(in);\n\n// Parse JSON from Reader\nReader reader = getReader(\"JSON/bodyweight.json\");\nObservation observation = FHIRParser.parser(Format.JSON).parse(reader);\n```\n\nThe model also supports parsing XML.\nIf you already have JSON or XML in a java.lang.String, you can wrap that in a StringReader.\n\n## Generating JSON and XML formats from a Resource instance\n\n```\n// Generate JSON format\nFHIRGenerator.generator(Format.JSON).generate(bodyWeight, System.out);\n\n// Generate XML format\nFHIRGenerator.generator(Format.XML).generate(bodyWeight, System.out);\n```\n\nThe `FHIRGenerator` interface has a separate factory method that takes `boolean prettyPrinting` as a parameter:\n\n```\n// Generate JSON format (with pretty printing)\nFHIRGenerator.generator(Format.JSON, true).generate(bodyWeight, System.out);\n```\n\nTo generate either format to a java.lang.String, you can pass the generate method a StringWriter.\n\n## Evaluating FHIRPath expressions on a Resource instance\n\nThe fhir-path module implements HL7 FHIRPath 2.0 for evaluating FHIRPath expressions against the model objects.\n\nFor example:\n```\nEvaluationContext evaluationContext = new EvaluationContext(bodyWeight);\nCollection<FHIRPathNode> result = FHIRPathEvaluator.evaluator().evaluate(evaluationContext, \"Observation.value.as(Quantity).value >= 200\");\nassert(FHIRPathUtil.isTrue(result));\n```\n\nThe `EvaluationContext` class builds a `FHIRPathTree` from a FHIR resource or element. A `FHIRPathTree` is a tree of labeled nodes that wrap FHIR elements and are used by the FHIRPath evaluation engine (`FHIRPathEvaluator`).\n\n## Validating a Resource instance\n\nSchema-level validation occurs during object construction. This includes validation of cardinality constraints and value domains. Additional validation of constraints specified in the model is performed using the `FHIRValidator` class from the fhir-validation module.\n\n```\nObservation observation = getObservation();\n\nList<Issue> issues = FHIRValidator.validator().validate(observation);\n\nfor (Issue issue : issues) {\n    if (IssueSeverity.ERROR.equals(issue.getSeverity())) {\n        // handle error\n    }\n}\n```\n\nSee the [Validation Guide](FHIRValidationGuide) for more information.\n\n## Using the FHIR model with JAX-RS\n\nJava and XML - Restful Services (JAX-RS) is an API specification for building and consuming HTTP-based interfaces in Java.\nThe LinuxForHealth fhir-core module defines FHIR media types (`application/fhir+xml` and `application/json+xml`) and the fhir-provider module implements JAX-RS providers that use the fhir-model Parsers and Generators to read and write these media types.\n\nTo integrate the LinuxForHealth JAX-RS providers with your own JAX-RS implementation, you must register a provider. For example, when building a JAX-RS client:\n```\nClientBuilder cb = ClientBuilder.newBuilder()\n        .register(new FHIRProvider(RuntimeType.CLIENT));\n```\n\nThere are other providers for working with FHIR data through the jakarta.json API (`FHIRJsonProvider`) and JSONPatch (`FHIRJsonPatchProvider`).","type":"Mdx","contentDigest":"1433444814c03e6a34a695af14f853cd","owner":"gatsby-plugin-mdx","counter":104,"fieldOwners":{"slug":"gatsby-plugin-slug"}},"frontmatter":{"title":"FHIR Model Guide","slug":"/FHIR/guides/FHIRModelGuide","date":"2019-10-25 12:00:00 -0400"},"exports":{},"rawBody":"---\nslug:  \"/FHIR/guides/FHIRModelGuide\"\ntitle: \"FHIR Model Guide\"\ndate:  \"2019-10-25 12:00:00 -0400\"\n---\n\n## Overview\n\nThe FHIR model component provides Java APIs for parsing, building, generating and validating FHIR resources. Java model classes that represent FHIR resources and data types are generated directly from the structure definitions distributed with the spec. All model objects are thread-safe and immutable. Each model class implements the Java builder pattern (Effective Java, Joshua Bloch) and the visitor pattern (GoF). The classes also implement Java equals, hashCode and toString methods. All date/time processing is done using the Java time library.\n\nMany of the data type classes include additional factory methods to facilitate object construction for common use cases. The model includes generated Javadoc comments complete with excerpts taken directly from the specification. Model classes also include Java annotations for constraints (`@Constraint`), required elements (`@Required`), choice element types (`@Choice`) and value set bindings (`@Binding`). Value set bindings are implemented using Code subclasses with constant fields and nested enumerations. Backbone elements are implemented as Java nested classes to keep them organized.\n\nAll schema-level (structure, cardinality, value domain) and global (empty resource, empty element) constraint validation is happens during object construction. This means that it is virtually impossible to build a schema invalid FHIR resource using the APIs. Additional constraint validation (invariants, profile, terminology) is performed using the FHIRValidator class. FHIRParser and FHIRGenerator classes are used to parse and generate both JSON and XML formats. FHIRPathEvaluator is a FHIRPath evaluation engine built on an ANTLR4 generated parser. It implements are large portion of the FHIRPath specification and is used for validation and search parameter value extraction.\n\n## Building a Resource using the FHIR Model API\n\nThe FHIR model API implements the Builder pattern for constructing Resource instances.\n\n```\nObservation bodyWeight = Observation.builder()\n    .meta(Meta.builder()\n        .profile(Canonical.of(\"http://hl7.org/fhir/StructureDefinition/bodyweight\"))\n        .build())\n    .status(ObservationStatus.FINAL)\n    .effective(DateTime.builder()\n        .value(\"2019-01-01\")\n        .build())\n    .category(CodeableConcept.builder()\n        .coding(Coding.builder()\n            .system(Uri.of(\"http://terminology.hl7.org/CodeSystem/observation-category\"))\n            .code(Code.of(\"vital-signs\"))\n            .build())\n        .build())\n    .code(CodeableConcept.builder()\n        .coding(Coding.builder()\n            .system(Uri.of(\"http://loinc.org\"))\n            .code(Code.of(\"29463-7\"))\n            .build())\n        .build())\n    .value(Quantity.builder()\n        .value(Decimal.of(200))\n        .system(Uri.of(\"http://unitsofmeasure.org\"))\n        .code(Code.of(\"[lb_av]\"))\n        .unit(\"lbs\")\n        .build())\n    .build();\n```\n\nIn the example above, a number of different builder classes are used:\n\n- `Observation.Builder`\n- `DateTime.Builder`\n- `CodeableConcept.Builder`\n- `Quantity.Builder`\n\nEvery type in the model that represents a FHIR resource or element has a corresponding nested, static Builder class used for constructing thread-safe, immutable instances.\n\nSeveral static factory / utility methods are also used:\n\n- `Canonical.of(...)`\n- `Uri.of(...)`\n- `Code.of(...)`\n\nMany of the primitive data types contain this type of \"helper\" method.\n\n## Modifying a model object\n\nAlthough model objects are immutable, the `toBuilder()` method can be used to construct a builder with the same values.\nThis builder can then be modified and built into a new model object.\n```\nObservation modifiedBodyWeight = bodyWeight.toBuilder()\n    .value(bodyWeight.getValue().as(Quantity.class).toBuilder()\n        .value(Decimal.of(210))\n        .build())\n    .build();\n```\n\nAlternatively, if the fhir-path module is included, objects can be modified via FHIRPathUtil or FHIRPathPatch.\n```\n// Using FHIRPathUtil\nObservation patchedBodyWeight1 = FHIRPathUtil.replace(bodyWeight, \"Observation.value.value\", Decimal.of(210));\n\n// Using FHIRPathPatch (useful if applying a series of patches to many resource instances)\nFHIRPathPatch patch = FHIRPathPatch.builder()\n    .replace(\"Observation.value.value\", Decimal.of(210))\n    .build();\nObservation patchedBodyWeight2 = patch.apply(bodyWeight);\n```\n\n## Parsing a Resource from an InputStream or Reader\n\n```\n// Parse JSON from InputStream\nInputStream in = getInputStream(\"JSON/bodyweight.json\");\nObservation observation = FHIRParser.parser(Format.JSON).parse(in);\n\n// Parse JSON from Reader\nReader reader = getReader(\"JSON/bodyweight.json\");\nObservation observation = FHIRParser.parser(Format.JSON).parse(reader);\n```\n\nThe model also supports parsing XML.\nIf you already have JSON or XML in a java.lang.String, you can wrap that in a StringReader.\n\n## Generating JSON and XML formats from a Resource instance\n\n```\n// Generate JSON format\nFHIRGenerator.generator(Format.JSON).generate(bodyWeight, System.out);\n\n// Generate XML format\nFHIRGenerator.generator(Format.XML).generate(bodyWeight, System.out);\n```\n\nThe `FHIRGenerator` interface has a separate factory method that takes `boolean prettyPrinting` as a parameter:\n\n```\n// Generate JSON format (with pretty printing)\nFHIRGenerator.generator(Format.JSON, true).generate(bodyWeight, System.out);\n```\n\nTo generate either format to a java.lang.String, you can pass the generate method a StringWriter.\n\n## Evaluating FHIRPath expressions on a Resource instance\n\nThe fhir-path module implements HL7 FHIRPath 2.0 for evaluating FHIRPath expressions against the model objects.\n\nFor example:\n```\nEvaluationContext evaluationContext = new EvaluationContext(bodyWeight);\nCollection<FHIRPathNode> result = FHIRPathEvaluator.evaluator().evaluate(evaluationContext, \"Observation.value.as(Quantity).value >= 200\");\nassert(FHIRPathUtil.isTrue(result));\n```\n\nThe `EvaluationContext` class builds a `FHIRPathTree` from a FHIR resource or element. A `FHIRPathTree` is a tree of labeled nodes that wrap FHIR elements and are used by the FHIRPath evaluation engine (`FHIRPathEvaluator`).\n\n## Validating a Resource instance\n\nSchema-level validation occurs during object construction. This includes validation of cardinality constraints and value domains. Additional validation of constraints specified in the model is performed using the `FHIRValidator` class from the fhir-validation module.\n\n```\nObservation observation = getObservation();\n\nList<Issue> issues = FHIRValidator.validator().validate(observation);\n\nfor (Issue issue : issues) {\n    if (IssueSeverity.ERROR.equals(issue.getSeverity())) {\n        // handle error\n    }\n}\n```\n\nSee the [Validation Guide](FHIRValidationGuide) for more information.\n\n## Using the FHIR model with JAX-RS\n\nJava and XML - Restful Services (JAX-RS) is an API specification for building and consuming HTTP-based interfaces in Java.\nThe LinuxForHealth fhir-core module defines FHIR media types (`application/fhir+xml` and `application/json+xml`) and the fhir-provider module implements JAX-RS providers that use the fhir-model Parsers and Generators to read and write these media types.\n\nTo integrate the LinuxForHealth JAX-RS providers with your own JAX-RS implementation, you must register a provider. For example, when building a JAX-RS client:\n```\nClientBuilder cb = ClientBuilder.newBuilder()\n        .register(new FHIRProvider(RuntimeType.CLIENT));\n```\n\nThere are other providers for working with FHIR data through the jakarta.json API (`FHIRJsonProvider`) and JSONPatch (`FHIRJsonPatchProvider`).","fileAbsolutePath":"/home/runner/work/FHIR/FHIR/fhir/docs/src/pages/guides/FHIRModelGuide.md","fields":{"slug":"//FHIR/guides/FHIRModelGuide"}}}},"staticQueryHashes":["1364590287","2102389209","2102389209","227138135","227138135","2456312558","2746626797","2746626797","3018647132","3018647132","3906363820","3906363820","768070550"]}